---
marp: true
author: caquintella@gmail.com
backgroundColor: white
paginate: true
theme: default

---

# Busca #

Professor: Carlos Alvaro Quintella

---

## Introdução ##

Dada uma coleção de elementos, existem três perguntas que podemos fazer.

1. Existência: O elemento de interesse existe na coleção?
2. Recuperação: Recupera o(s) elemento(s) na coleção que satisfaça a(s) condição(ões) específica(s) desejada(s).
3. Busca Associativa: Recuperar as informações dos elementos que estão associados a chave(s) de acesso específica(s).

---

## Busca sequencial ##

A busca sequencial é um método simples de pesquisa que procura um elemento em uma coleção de dados, como um vetor ou uma lista, verificando cada elemento sequencialmente até encontrar o elemento desejado ou percorrer toda a coleção sem encontrá-lo.

---

### Vantagens da busca sequencial ###

* Solução mais intuitiva e simples;
* Usa força bruta para percorrer a estrutura de dados com todos os elementos até encontrar o elemento de interesse.
* Não precisa que a lista ou vetor esteja ordenada.
* Pode ser usado com qualquer tipo de dado.

### Desvantagens da busca sequencial ###

* É ineficiênte, A complexidade do tempo de busca sequencial é O(n),
* Não apropriada para coleções de dados grandes.
* Não permite pesquisas rápidas.

---

### Pseudo código para busca sequencial ###

1. Receba o valor a ser procurado (chave)
2. Inicialize um contador com o valor 0
3. Repita o seguinte enquanto o contador for menor do que o tamanho da lista:
    *a.* Se o elemento na posição atual do contador for igual a chave, retorne o elemento encontrado,
    *b.* Incremente o contador.
4. Retorne "Elemento não encontrado".

---

## Apresentação da busca sequencial ##

````c
#include <stdio.h>


int busca_sequencial(int my_array[], int size, int target) {
  int indice;
  for (indice = 0; indice < size; i++) {
    if (my_array[indice] == target) {
      return indice;
    }
  }
  return -1;
}

````

---

````c

int main() {
  int arr[] = {10, 20, 30, 40, 50};
  int tamanho = sizeof(arr) / sizeof(arr[0]);
  int target = 30;
  int result = searchSequential(arr, size, target);
  if (result == -1) {
    printf("O elemento não foi encontrado no vetor.\n");
  } else {
    printf("O elemento foi encontrado na posição %d do vetor.\n", result);
  }
  return 0;
}

````

Neste exemplo, a função searchSequential recebe como entrada um vetor arr, o tamanho do vetor size e o elemento target que desejamos encontrar. A função retorna a posição do elemento no vetor, se ele existir, ou -1, caso contrário. O código principal no main chama a função searchSequential e imprime o resultado na tela.

---

## Busca Binária ##

A busca binária é um algoritmo de busca de dados que divide repetidamente a lista de elementos em dois pedaços e, em seguida, verifica se o elemento procurado está presente na metade esquerda ou direita. A busca só é realizada na metade relevante da lista, o que permite uma busca mais eficiente do que outros algoritmos de busca linear.

Para que a busca binária funcione corretamente, a lista precisa estar ordenada. Primeiro, é determinado o meio da lista e, em seguida, é comparado o elemento no meio da lista com o elemento procurado. Se o elemento procurado for menor que o elemento no meio, a busca é continuada na metade esquerda da lista. Se o elemento procurado for maior que o elemento no meio, a busca é continuada na metade direita da lista. Este processo é repetido até que o elemento seja encontrado ou até que não haja mais elementos na lista para procurar.

---

### Vantagens da Busca Binária ###

* Tempo de busca médio O(log n), onde n é o número de elementos na lista.
* Ideal para grandes conjuntos de dados.
* Fácil de implementar.

### Desvantagens da Busca Binária ###

* A lista deve estar ordenada antes da busca.
* Não é tão eficiente quanto a busca hash para conjuntos de dados pequenos.

---

## Implementação da Busca Binária ##

Pseudo-código:

````text
função busca_binária(vetor, alvo):
    esquerda = 0
    direita = tamanho(vetor) - 1
    
    enquanto esquerda <= direita:
        meio = (esquerda + direita) // 2
        
        se vetor[meio] == alvo:
            retornar meio
        senão, se vetor[meio] < alvo:
            esquerda = meio + 1
        senão:
            direita = meio - 1
            
    retornar -1
````

 ---

````c
#include <stdio.h>

int buscaBinaria(int arr[], int l, int r, int x) {
    while (l <= r) {
        int m = l + (r - l) / 2;

        if (arr[m] == x)
            return m;

        if (arr[m] < x)
            l = m + 1;
        else
            r = m - 1;
    }

    return -1;
}
````

---

````c

int main(void) {
    int arr[] = { 2, 3, 4, 10, 40 };
    int n = sizeof(arr) / sizeof(arr[0]);
    int x = 10;
    int result = buscaBinaria(arr, 0, n - 1, x);
    (result == -1) ? printf("Elemento não presente no array")
                  : printf("Elemento presente no index %d", result);
    return 0;
}
````

---

Neste exemplo, a função buscaBinaria recebe como argumentos um array arr, os índices inicial e final e e o elemento a ser procurado x. A função retorna o índice do elemento na lista se ele for encontrado, caso contrário, retorna -1.

---

## Busca: binária vs. sequencial ##

|Busca Sequencial|Busca Binária|
|---|---|
|Não precisa que dados sejam ordenados|Precisa que dados sejam ordenados|
|Mais acessos à memória|Menos acessos à memória|
|Simples de Implementar|Mais rápido|
|ineficiente para listas grandes|Não funciona para listas dinâmicas|
|Complexidade no pior caso: O(n)| Complexidade no pior caso: O (log n)|

---

## Tabelas de símbolos ##

As tabelas de símbolos são estruturas de dados que associam um valor a uma chave, permitindo a busca e recuperação posterior do valor a partir da chave. Essas estruturas são conhecidas por vários nomes, incluindo dicionários e índices, dependendo da aplicação.

A busca é uma operação fundamental em muitas aplicações computacionais, tornando as tabelas de símbolos um recurso importante em muitos ambientes de programação.

Um índice de um livro é um exemplod e tabela símbolo.

---

## Hash ##

Um algoritmo de hash é uma função matemática que recebe dados de tamanho arbitrário e produz uma saída de tamanho fixo chamada valor de hash ou digest. A ideia principal por trás dos algoritmos de hash é que eles são projetados para ser uma função unidirecional, ou seja, é fácil calcular o valor de hash dado os dados, mas é computacionalmente inviável calcular os dados originais dado o valor de hash. Os algoritmos de hash são amplamente utilizados na ciência da computação para uma variedade de aplicações, incluindo criptografia de dados, assinaturas digitais e verificação de integridade de dados.

---

![Fução unidirecional](https://external-content.duckduckgo.com/iu/?u=http%3A%2F%2F2.bp.blogspot.com%2F-xWrlcNgx2_c%2FUHxYgMNoxlI%2FAAAAAAAAA8k%2FrzTo7Nsj_eg%2Fs1600%2Falgoritmos-hash-unid-img3.png&f=1&nofb=1&ipt=e01c79dd8a81c5b149575733573fc3bd60e6ba0c1c13fc9a9ba7b3fadfdd250f&ipo=images)

---

### MD5 ###

O MD5 é um algoritmo de hash amplamente utilizado na computação, criado por Ronald Rivest em 1991. Ele produz um valor de hash de 128 bits, que é amplamente utilizado para verificar a integridade de dados em sistemas de arquivos, criptografia de senhas, e outras aplicações de segurança.

---

O algoritmo MD5 é projetado para ser uma função unidirecional, o que significa que é fácil calcular o valor de hash de uma entrada, mas é matematicamente inviável reverter o processo para obter a entrada original. Isso torna o MD5 útil para verificar a integridade de dados, pois se os dados forem alterados de alguma forma, o valor de hash resultante será diferente do original.

**Nota**: o MD5, é considerado obsoleto para aplicações de segurança mais críticas, pois foram descobertas vulnerabilidades. Os algoritmos de hash mais seguros são:  SHA-256 e o SHA-3, que são os recomendados para aplicações de segurança mais importantes.

---

## Um exemplo simples de como fazer hashing ##

é possível fazer hashing usando o resto de divisão por primos. Essa abordagem é conhecida como hashing por divisão.

> É preferível escolher como tamanho da tabela de hash um número primo para evitar possíveis colisões desnecessárias entre chaves que mapeiam para a mesma posição na tabela. A divisão por um número primo como M garante que o resultado final seja mais "aleatório", distribuindo as chaves de forma mais uniforme. Se fosse escolhido um número não-primo como o tamanho da tabela de hash, isso poderia resultar em uma distribuição de chaves menos uniforme e um maior número de colisões. Além disso, escolher um número primo garante que não haverá um fator comum entre o tamanho da tabela e a chave, evitando possíveis padrões na distribuição das chaves.

---

O processo de hashing por divisão envolve dividir o valor da chave pela quantidade de slots disponíveis na tabela hash e usar o resto da divisão da chave como o índice para armazenar o valor na tabela hash.

Por exemplo, se a chave for 20 e a tabela hash tiver 11 slots, o índice seria 20 % 10 = 9. O valor seria então armazenado no slot 9 da tabela hash.

---

Para chaves que são números, a técnica mais comum é o hashing modular, onde o tamanho do array é escolhido como um número primo e, para qualquer número inteiro positivo de chave k, é computado o resto da divisão de k por M. Se as chaves forem reais entre 0 e 1, pode-se multiplicá-las por M e arredondá-las para o inteiro mais próximo. Já para strings, pode-se tratar cada caractere como um número inteiro, computando o hash como um número grande.

---

### Exercício ###

Construa um vetor de vinte posiçõe, onde cada um terá um ponteiro para uma lista encadeada de valores.

---

### Tabela Hash ###

Uma tabela de hash é uma estrutura de dados que usa funções de hash para mapear chaves em índices em um array.
A ideia básica por trás de uma tabela de hash é usar uma função de hash para calcular um índice no array onde o valor correspondente deve ser armazenado.
Quando um valor é adicionado à tabela de hash, sua chave é "hasheada" para calcular o índice no array onde ele deve ser armazenado. Se já houver um valor armazenado nesse índice, a tabela de hash deve lidar com a colisão, encadeando os valores em uma lista ligada ou usando outro método para resolver o conflito (como hashing duplo e sondagem quadrática).

---

As tabelas de hash são importantes porque permitem uma pesquisa eficiente de chave-valor, com tempo médio de busca de O(1), o que significa que o tempo necessário para encontrar um valor na tabela de hash não depende do tamanho da tabela. As tabelas de hash são usadas em uma ampla variedade de aplicações, incluindo indexação de bancos de dados, tabelas de símbolos de compilador e cache da web.

---

![hash map](https://external-content.duckduckgo.com/iu/?u=https%3A%2F%2Fwww.logicbig.com%2Ftutorials%2Fcore-java-tutorial%2Fjava-collections%2Fhash-map-equal-and-hash-code%2Fimages%2Fhashtable-data-structure.png&f=1&nofb=1&ipt=b0f3a4d547105ef8283b193ce1e9f0f3ef689599f6175b5f8469c5477959903f&ipo=images)

---

![hash](https://external-content.duckduckgo.com/iu/?u=https%3A%2F%2Fiq.opengenus.org%2Fcontent%2Fimages%2F2019%2F04%2Fhash_map_flow.jpg&f=1&nofb=1&ipt=0e6e238f035828b70c042d709adb0b01c9dfb4e40c116e3b5d254f30ba317fbc&ipo=images)

---

### Hash Maps ##

Mapa hash é uma estrutura de dados que implementa uma tabela de símbolos usando uma tabela hash, onde cada entrada na tabela hash contém uma lista vinculada de pares chave-valor. Essa estrutura de dados permite inserções, buscas e exclusões de pares chave-valor em tempo constante (amortizado), tornando-a muito eficiente para lidar com grandes quantidades de dados.

---

Geralmente, a diferença entre uma tabela hash e um mapa hash está na maneira como os dados são armazenados. Uma tabela hash é uma estrutura de dados que usa uma matriz ou vetor para armazenar os pares de chave-valor, onde a chave é mapeada para um índice na matriz. Em contraste, um mapa hash é uma estrutura de dados que geralmente usa uma tabela hash internamente, mas também inclui recursos adicionais, como capacidade de expansão dinâmica, manipulação de colisões e métodos mais abrangentes para adicionar, remover e buscar elementos

---

## Busca Hash ##

A técnica de hashing é um exemplo clássico de tradeoff entre tempo e espaço. Ela permite um equilíbrio razoável entre memória e tempo para realizar operações em tabelas de símbolos que requerem tempo constante por operação em situações típicas.

--

O algoritmo é eficiente para operações de inserção e pesquisa, pois usa a função hash para gerar um índice em tempo constante.

No entanto, o algoritmo é propenso a colisões, ou seja, vários elementos podem ter o mesmo índice gerado pela função hash. Para lidar com isso, existem vários mecanismos, como encadeamento e resolução linear.

---

### Vantagens da busca com tabela hash ###

* Tempo de pesquisa constante: a busca é realizada em tempo constante, independentemente do tamanho da tabela hash.
* A busca é mais rápida do que a busca linear ou binária, especialmente para grandes quantidades de dados.
* O algoritmo é simples de implementar e não requer estruturas de dados complexas.

---

### Desvantagens da busca com tabela hash ###

* A função hash pode gerar índices iguais para chaves diferentes, o que resulta em colisões, pode desequilibrar as buscas.
* precisa de espaço p/ armazenar a tabela hash precisa de espaço adicional para armazenar informações adicionais, como links para tratar colisões.
* A qualidade da função hash é crítica para o desempenho do algoritmo. Uma má função hash pode resultar em muitas colisões e afetar negativamente o desempenho do algoritmo.

---

## Resumo ##

Falamos sobre algoritmos de busca, apresentando a busca sequencial e a busca binária como exemplos.

* A busca sequencial é um método simples e intuitivo para encontrar um elemento em uma coleção de dados, como um vetor ou uma lista, mas é ineficiente para grandes conjuntos de dados.
* Por outro lado, a busca binária é um algoritmo mais rápido e eficiente, pois divide a lista em dois pedaços e verifica se o elemento procurado está presente na metade esquerda ou direita.
  
---
  
As tabelas de símbolos, que associam um valor a uma chave, permitem a busca e recuperação posterior do valor a partir da chave.
Os algoritmos de hash são usados para fazer hashing, que é uma técnica para associar uma chave a um índice em uma tabela hash. A tabela hash é uma estrutura de dados que usa funções de hash para mapear chaves em índices em um array.

As tabelas de hash são importantes porque permitem uma pesquisa eficiente de chave-valor, com tempo médio de busca de O(1), o que significa que o tempo necessário para encontrar um valor na tabela de hash não depende do tamanho da tabela.

---

## Perguntas ##

* Quais são as vantagens e desvantagens da busca sequencial?
* O que é uma tabela de símbolos?
* Qual é o objetivo principal dos algoritmos de hash?
* Qual é a complexidade de tempo da busca binária em comparação com a busca sequencial?

---

## Links ##
