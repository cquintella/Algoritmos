---
marp: true
author: caquintella@gmail.com
backgroundColor: white
paginate: true
theme: default

---

# Busca #

Professor: Carlos Alvaro Quintella

A busca por informações é uma atividade fundamental para a humanidade e tem sido realizada desde tempos imemoriais. Com o advento da tecnologia, novas formas de busca foram criadas, como os algoritmos de busca. Mas o que são algoritmos de busca? Por que são importantes? Quais são as aplicações e desafios?

---

![BUSCANDO bg](https://images.unsplash.com/photo-1501250987900-211872d97eaa?ixlib=rb-4.0.3&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=870&q=80)

---

## Introdução ##

Dada uma coleção de elementos, existem três perguntas que podemos fazer.

1. Existência: O elemento de interesse existe na coleção?
2. Recuperação: Recupera o(s) elemento(s) na coleção que satisfaça a(s) condição(ões) específica(s) desejada(s).
3. Busca Associativa: Recuperar as informações dos elementos que estão associados a chave(s) de acesso específica(s).

---

## Conceito de busca ##

A Busca é a operação que nos permite encontrar elementos em uma coleção, de acordo com **critérios específicos**.

Vamos explorar um pouco mais sobre cada tipo de busca:

* Busca de existência: essa busca nos permite verificar se um elemento específico existe em uma coleção. É uma operação simples, mas fundamental para muitos algoritmos.
* Busca por recuperação: essa busca nos permite encontrar elementos que atendam a determinadas condições. Por exemplo, podemos buscar todos os números pares em uma lista de números.
* Busca associativa: essa busca nos permite recuperar informações associadas a chaves específicas. Por exemplo, podemos ter uma lista de contatos telefônicos e buscar o número de telefone de um contato específico pelo seu nome.

---

Os algoritmos de busca são ferramentas que nos ajudam a encontrar informações em uma grande quantidade de dados. Eles são utilizados em diversas áreas, como em motores de busca, em bancos de dados, em jogos, em inteligência artificial, entre outros.

---

A origem dos algoritmos de busca remonta aos primórdios da ciência da computação. Desde o início, pesquisadores procuraram maneiras eficientes de buscar informações em grandes conjuntos de dados. Esses algoritmos são baseados em diferentes técnicas, como busca sequencial, busca binária, busca em árvore, busca em grafo, entre outros.

---

Mas por que os algoritmos de busca são importantes? Imagine ter que buscar uma informação específica em um livro com milhares de páginas. Seria muito difícil e demorado encontrar essa informação sem uma ferramenta de busca. O mesmo acontece com as informações digitais. Sem algoritmos de busca, seria muito difícil encontrar informações em bancos de dados, por exemplo.

As aplicações dos algoritmos de busca são inúmeras. Eles são utilizados em sistemas de recomendação, em jogos de tabuleiro, em robótica, em processamento de linguagem natural, em análise de sentimentos, em buscas em redes sociais, entre outros.

---

No entanto, existem também desafios na utilização dos algoritmos de busca. Um dos principais desafios é a escolha do algoritmo mais adequado para cada situação. Alguns algoritmos são mais eficientes para conjuntos de dados pequenos, enquanto outros são mais eficientes para conjuntos de dados grandes. Além disso, os algoritmos de busca também podem ser afetados por fatores como a qualidade dos dados, a presença de ruído nos dados e a forma como os dados são organizados.

Vamos começar nossa jornada para conhecer os algoritimos de busca e suas aplicações.

---


## Busca sequencial ##

A busca sequencial é um algoritmo simples que percorre uma lista de elementos de forma linear, elemento a elemento, até encontrar o elemento de interesse ou até chegar ao fim da lista. É um algoritmo utilizado em diversas aplicações que envolvem a busca de informações em grandes coleções de dados.

---

### Origem e Importância da Busca Sequencial ###

A busca sequencial é um algoritmo antigo e simples, que tem sua origem nas primeiras aplicações computacionais. Apesar de ser ineficiente para coleções de dados grandes, a busca sequencial é ainda hoje um algoritmo útil em diversas aplicações, principalmente em coleções pequenas de dados.

---

###Desafios da Busca Sequencial ###

Um dos principais desafios da busca sequencial é a sua ineficiência para coleções de dados grandes, pois a complexidade do tempo de busca é O(n). Além disso, a busca sequencial é um algoritmo simples, que não apresenta muitas otimizações, e por isso pode ser menos eficiente em alguns casos.

---

### Aplicações da Busca Sequencial ###

A busca sequencial é amplamente utilizada em diversas aplicações, como em pesquisas de **elementos em listas não ordenadas** ou em coleções pequenas de dados. Outra aplicação é a validação de dados, como em formulários de cadastro, onde é possível verificar se um determinado valor já existe em uma coleção de dados.

---

### Vantagens da busca sequencial ###

* Solução mais intuitiva e simples;
* Usa força bruta para percorrer a estrutura de dados com todos os elementos até encontrar o elemento de interesse.
* Não precisa que a lista ou vetor esteja ordenada.
* Pode ser usado com qualquer tipo de dado.

### Desvantagens da busca sequencial ###

* É ineficiênte, A complexidade do tempo de busca sequencial é O(n),
* Não apropriada para coleções de dados grandes.
* Não permite pesquisas rápidas.

---

### Pseudo código para busca sequencial ###

1. Receba o valor a ser procurado (chave)
2. Inicialize um contador com o valor 0
3. Repita o seguinte enquanto o contador for menor do que o tamanho da lista:
    *a.* Se o elemento na posição atual do contador for igual a chave, retorne o elemento encontrado,
    *b.* Incremente o contador.
4. Retorne "Elemento não encontrado".

---

## Apresentação da busca sequencial ##

````c
#include <stdio.h>


int busca_sequencial(int vetor[], int tamanho, int alvo) {
  
  for (int i = 0; i < size; i++) {
    if (vetor[i] == alvo) {
      return i;
    }
  }
  return -1;
}

````

---

````c

int main() {

  // Dado o vetor abaixo:
  int vetor[] = {10, 20, 30, 40, 50};
  
  // Com o tamanho de:
  int tamanho = sizeof(arr) / sizeof(arr[0]);
  
  // Queremos encontrar o target
  int alvo = 30;
  
  // Usaremos nossa função busca_sequencial:
  int resultado = busca_sequencial(vetor, tamanho, alvo);
  
  if (result == -1) {
    printf("O elemento não foi encontrado no vetor.\n");
  } else {
    printf("O elemento foi encontrado na posição %d do vetor.\n", result);
  }
  return 0;
}

````

---

## Busca Binária ##

A busca binária é um algoritmo eficiente de busca de dados que pode ser usado para encontrar um elemento em uma lista ordenada. A grande vantagem da busca binária em relação à busca sequencial é que a busca binária pode encontrar o elemento desejado em um número de tentativas muito menor.

**A busca binária é uma técnica eficiente de busca que utiliza a ideia de dividir para conquistar.**

---

Para que a busca binária funcione corretamente, **é necessário que a lista esteja ordenada**. Primeiro, é determinado o meio da lista e, em seguida, é comparado o elemento no meio da lista com o elemento procurado. Se o elemento procurado for menor que o elemento no meio, a busca é continuada na metade esquerda da lista. Se o elemento procurado for maior que o elemento no meio, a busca é continuada na metade direita da lista. Este processo é repetido até que o elemento seja encontrado ou até que não haja mais elementos na lista para procurar.

---

Para implementar a busca binária, é necessário seguir alguns passos simples. Primeiro, a lista deve ser ordenada. Em seguida, é possível implementar a busca usando um laço while que divide a lista em duas metades e, em seguida, compara o elemento central com o elemento procurado. O processo de divisão em duas metades é repetido até que o elemento desejado seja encontrado ou até que não haja mais elementos na lista para procurar.

---

o algoritmo divide repetidamente a lista em duas partes, verifica em qual das duas partes o elemento procurado pode estar e continua a busca somente na metade relevante da lista, eliminando a outra metade. Isso permite que a busca seja mais eficiente do que outros algoritmos de busca linear, que precisam verificar cada elemento sequencialmente.

O processo de busca começa determinando o meio da lista e comparando o elemento no meio com o elemento procurado. Se o elemento procurado for menor que o elemento no meio, a busca continua na metade esquerda da lista, caso contrário, a busca continua na metade direita da lista. Esse processo é repetido até que o elemento seja encontrado ou até que não haja mais elementos na lista para procurar.

---

### Vantagens da Busca Binária ###

* Tempo de busca médio O(log n), onde n é o número de elementos na lista.
* Ideal para grandes conjuntos de dados.
* Fácil de implementar.

### Desvantagens da Busca Binária ###

* A lista deve estar ordenada antes da busca.
* Não é tão eficiente quanto a busca hash para conjuntos de dados pequenos.

---

## Implementação da Busca Binária ##

Pseudo-código:

````text
função busca_binária(vetor, alvo):
    esquerda = 0
    direita = tamanho(vetor) - 1
    
    enquanto esquerda <= direita:
        meio = (esquerda + direita) // 2
        
        se vetor[meio] == alvo:
            retornar meio
        senão, se vetor[meio] < alvo:
            esquerda = meio + 1
        senão:
            direita = meio - 1
            
    retornar -1
````

 ---

````c
#include <stdio.h>

int busca_binaria(int vetor[], int tamanho, int alvo) {

int esquerda = 0;
int direita = tamanho - 1;

while (esquerda <= direita) {
    int meio = esquerda + (direita - esquerda) / 2;

    if (vetor[meio] == alvo)
        return meio;

    if (vetor[meio] < alvo)
        esquerda = meio + 1;
    else
        direita = meio - 1;
}

return -1;

````

---

````c

int main(void) {
    // Considere o vetor
    int vetor[] = { 2, 3, 4, 10, 40, 255, 342, 1, 234, 99, 1024, 13, 17, 21 };
    
    // Com tamanho:
    int tamanho = sizeof(arr) / sizeof(arr[0]);
    
    // procuramos o alvo:
    int alvo = 10;
    
    int result = busca_binaria(vetor, tamanho, alvo);
    
    (result == -1) ? printf("Elemento não presente no array")
                  : printf("Elemento presente no index %d", result);
    return 0;
}
````

---


## Busca: binária vs. sequencial ##

|Busca Sequencial|Busca Binária|
|---|---|
|Não precisa que dados sejam ordenados|Precisa que dados sejam ordenados|
|Mais acessos à memória|Menos acessos à memória|
|Simples de Implementar|Mais rápido|
|ineficiente para listas grandes|Não funciona para listas dinâmicas|
|Complexidade no pior caso: O(n)| Complexidade no pior caso: O (log n)|

---

## Tabelas de símbolos ##

As tabelas de símbolos são estruturas de dados que associam um valor a uma chave, permitindo a busca e recuperação posterior do valor a partir da chave. Essas estruturas são conhecidas por vários nomes, incluindo dicionários e índices, dependendo da aplicação.

A busca é uma operação fundamental em muitas aplicações computacionais, tornando as tabelas de símbolos um recurso importante em muitos ambientes de programação.

Um índice de um livro é um exemplod e tabela símbolo.

---

## Hash ##

Um algoritmo de hash é uma função matemática que recebe dados de tamanho arbitrário e produz uma saída de tamanho fixo chamada valor de hash ou digest. A ideia principal por trás dos algoritmos de hash é que eles são projetados para ser uma função unidirecional, ou seja, é fácil calcular o valor de hash dado os dados, mas é computacionalmente inviável calcular os dados originais dado o valor de hash. Os algoritmos de hash são amplamente utilizados na ciência da computação para uma variedade de aplicações, incluindo criptografia de dados, assinaturas digitais e verificação de integridade de dados.

---

![Fução unidirecional](https://external-content.duckduckgo.com/iu/?u=http%3A%2F%2F2.bp.blogspot.com%2F-xWrlcNgx2_c%2FUHxYgMNoxlI%2FAAAAAAAAA8k%2FrzTo7Nsj_eg%2Fs1600%2Falgoritmos-hash-unid-img3.png&f=1&nofb=1&ipt=e01c79dd8a81c5b149575733573fc3bd60e6ba0c1c13fc9a9ba7b3fadfdd250f&ipo=images)

---

### MD5 ###

O MD5 é um algoritmo de hash amplamente utilizado na computação, criado por Ronald Rivest em 1991. Ele produz um valor de hash de 128 bits, que é amplamente utilizado para verificar a integridade de dados em sistemas de arquivos, criptografia de senhas, e outras aplicações de segurança.

---

O algoritmo MD5 é projetado para ser uma função unidirecional, o que significa que é fácil calcular o valor de hash de uma entrada, mas é matematicamente inviável reverter o processo para obter a entrada original. Isso torna o MD5 útil para verificar a integridade de dados, pois se os dados forem alterados de alguma forma, o valor de hash resultante será diferente do original.

**Nota**: o MD5, é considerado obsoleto para aplicações de segurança mais críticas, pois foram descobertas vulnerabilidades. Os algoritmos de hash mais seguros são:  SHA-256 e o SHA-3, que são os recomendados para aplicações de segurança mais importantes.

---

## Um exemplo simples de como fazer hashing ##

é possível fazer hashing usando o resto de divisão por primos. Essa abordagem é conhecida como hashing por divisão.

> É preferível escolher como tamanho da tabela de hash um número primo para evitar possíveis colisões desnecessárias entre chaves que mapeiam para a mesma posição na tabela. A divisão por um número primo como M garante que o resultado final seja mais "aleatório", distribuindo as chaves de forma mais uniforme. Se fosse escolhido um número não-primo como o tamanho da tabela de hash, isso poderia resultar em uma distribuição de chaves menos uniforme e um maior número de colisões. Além disso, escolher um número primo garante que não haverá um fator comum entre o tamanho da tabela e a chave, evitando possíveis padrões na distribuição das chaves.

---

O processo de hashing por divisão envolve dividir o valor da chave pela quantidade de slots disponíveis na tabela hash e usar o resto da divisão da chave como o índice para armazenar o valor na tabela hash.

Por exemplo, se a chave for 20 e a tabela hash tiver 11 slots, o índice seria 20 % 10 = 9. O valor seria então armazenado no slot 9 da tabela hash.

---

Para chaves que são números, a técnica mais comum é o hashing modular, onde o tamanho do array é escolhido como um número primo e, para qualquer número inteiro positivo de chave k, é computado o resto da divisão de k por M. Se as chaves forem reais entre 0 e 1, pode-se multiplicá-las por M e arredondá-las para o inteiro mais próximo. Já para strings, pode-se tratar cada caractere como um número inteiro, computando o hash como um número grande.

---

### Exercício ###

Construa um vetor de vinte posiçõe, onde cada um terá um ponteiro para uma lista encadeada de valores.

---

### Tabela Hash ###

Uma tabela de hash é uma estrutura de dados que usa funções de hash para mapear chaves em índices em um array.
A ideia básica por trás de uma tabela de hash é usar uma função de hash para calcular um índice no array onde o valor correspondente deve ser armazenado.
Quando um valor é adicionado à tabela de hash, sua chave é "hasheada" para calcular o índice no array onde ele deve ser armazenado. Se já houver um valor armazenado nesse índice, a tabela de hash deve lidar com a colisão, encadeando os valores em uma lista ligada ou usando outro método para resolver o conflito (como hashing duplo e sondagem quadrática).

---

As tabelas de hash são importantes porque permitem uma pesquisa eficiente de chave-valor, com tempo médio de busca de O(1), o que significa que o tempo necessário para encontrar um valor na tabela de hash não depende do tamanho da tabela. As tabelas de hash são usadas em uma ampla variedade de aplicações, incluindo indexação de bancos de dados, tabelas de símbolos de compilador e cache da web.

---

![hash map](https://external-content.duckduckgo.com/iu/?u=https%3A%2F%2Fwww.logicbig.com%2Ftutorials%2Fcore-java-tutorial%2Fjava-collections%2Fhash-map-equal-and-hash-code%2Fimages%2Fhashtable-data-structure.png&f=1&nofb=1&ipt=b0f3a4d547105ef8283b193ce1e9f0f3ef689599f6175b5f8469c5477959903f&ipo=images)

---

![hash](https://external-content.duckduckgo.com/iu/?u=https%3A%2F%2Fiq.opengenus.org%2Fcontent%2Fimages%2F2019%2F04%2Fhash_map_flow.jpg&f=1&nofb=1&ipt=0e6e238f035828b70c042d709adb0b01c9dfb4e40c116e3b5d254f30ba317fbc&ipo=images)

---

### Hash Maps ##

Mapa hash é uma estrutura de dados que implementa uma tabela de símbolos usando uma tabela hash, onde cada entrada na tabela hash contém uma lista vinculada de pares chave-valor. Essa estrutura de dados permite inserções, buscas e exclusões de pares chave-valor em tempo constante (amortizado), tornando-a muito eficiente para lidar com grandes quantidades de dados.

---

Geralmente, a diferença entre uma tabela hash e um mapa hash está na maneira como os dados são armazenados. Uma tabela hash é uma estrutura de dados que usa uma matriz ou vetor para armazenar os pares de chave-valor, onde a chave é mapeada para um índice na matriz. Em contraste, um mapa hash é uma estrutura de dados que geralmente usa uma tabela hash internamente, mas também inclui recursos adicionais, como capacidade de expansão dinâmica, manipulação de colisões e métodos mais abrangentes para adicionar, remover e buscar elementos

---

## Busca Hash ##

A técnica de hashing é um exemplo clássico de tradeoff entre tempo e espaço. Ela permite um equilíbrio razoável entre memória e tempo para realizar operações em tabelas de símbolos que requerem tempo constante por operação em situações típicas.

--

O algoritmo é eficiente para operações de inserção e pesquisa, pois usa a função hash para gerar um índice em tempo constante.

No entanto, o algoritmo é propenso a colisões, ou seja, vários elementos podem ter o mesmo índice gerado pela função hash. Para lidar com isso, existem vários mecanismos, como encadeamento e resolução linear.

---

### Vantagens da busca com tabela hash ###

* Tempo de pesquisa constante: a busca é realizada em tempo constante, independentemente do tamanho da tabela hash.
* A busca é mais rápida do que a busca linear ou binária, especialmente para grandes quantidades de dados.
* O algoritmo é simples de implementar e não requer estruturas de dados complexas.

---

### Desvantagens da busca com tabela hash ###

* A função hash pode gerar índices iguais para chaves diferentes, o que resulta em colisões, pode desequilibrar as buscas.
* precisa de espaço p/ armazenar a tabela hash precisa de espaço adicional para armazenar informações adicionais, como links para tratar colisões.
* A qualidade da função hash é crítica para o desempenho do algoritmo. Uma má função hash pode resultar em muitas colisões e afetar negativamente o desempenho do algoritmo.

---

## Resumo ##

Falamos sobre algoritmos de busca, apresentando a busca sequencial e a busca binária como exemplos.

* A busca sequencial é um método simples e intuitivo para encontrar um elemento em uma coleção de dados, como um vetor ou uma lista, mas é ineficiente para grandes conjuntos de dados.
* Por outro lado, a busca binária é um algoritmo mais rápido e eficiente, pois divide a lista em dois pedaços e verifica se o elemento procurado está presente na metade esquerda ou direita.
  
---
  
As tabelas de símbolos, que associam um valor a uma chave, permitem a busca e recuperação posterior do valor a partir da chave.
Os algoritmos de hash são usados para fazer hashing, que é uma técnica para associar uma chave a um índice em uma tabela hash. A tabela hash é uma estrutura de dados que usa funções de hash para mapear chaves em índices em um array.

As tabelas de hash são importantes porque permitem uma pesquisa eficiente de chave-valor, com tempo médio de busca de O(1), o que significa que o tempo necessário para encontrar um valor na tabela de hash não depende do tamanho da tabela.

---

## Perguntas ##

* Quais são as vantagens e desvantagens da busca sequencial?
* O que é uma tabela de símbolos?
* Qual é o objetivo principal dos algoritmos de hash?
* Qual é a complexidade de tempo da busca binária em comparação com a busca sequencial?

---

## Links ##
